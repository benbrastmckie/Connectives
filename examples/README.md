# Examples Directory

Real execution examples showing what the Nice Connectives Solver produces.

## Overview

This directory contains actual output from running the solver with different configurations. These examples help users understand:
- What output to expect from different commands
- How long searches take
- What the progression from binary to ternary looks like
- How to interpret results

All examples were generated by running the commands documented in [USAGE.md](../USAGE.md).

---

## Example Files

### [binary_only_search.txt](binary_only_search.txt)

*Complete output from binary-only search demonstrating max size = 3*

**Command:**
```bash
python3 -m src.main --binary-only
```

**What it shows:**
- Search through all 16 binary connectives
- Progressive search from size 1 → 2 → 3 → 4 → 5
- Confirmation that max size = 3 (classical result)
- Example of 76 different size-3 nice sets found
- Timing information for each search size

**Key Insights:**
- Binary-only max is **3** (confirms classical result)
- Found 76 different maximal nice sets
- Size 4 and higher: **no nice sets exist** with binary only
- Total search time: ~5-6 seconds
- Most time spent checking sizes 4 and 5 (which have no solutions)

**Example Output Snippet:**
```
Size 3: Found 76 nice sets (0.24s)
Size 4: No nice sets found (1.41s)
Size 5: No nice sets found (3.96s)

RESULT: Maximum nice set size = 3

Example nice sets:
  Set 1: ['f2_0', 'f2_7', 'f2_9']
  Set 2: ['f2_0', 'f2_7', 'f2_10']
  Set 3: ['f2_0', 'f2_7', 'f2_12']
```

**Interpretation:**
- `f2_X` notation: binary function (arity 2) with truth table encoding X
- `f2_0` = constant FALSE (0000 in binary)
- `f2_7` = NOR (0001 in binary  - only true when both inputs false)
- `f2_9` = XNOR/IFF (1001 in binary - true when inputs match)

---

### [incremental_search_summary.txt](incremental_search_summary.txt)

*Summary of incremental search showing progression: binary (3) → unary (7) → ternary (16)*

**Command:**
```bash
python3 -m src.main --max-arity 3
```

**What it shows:**
- **Stage 1**: Add binary (arity 2) → max = 3
- **Stage 2**: Add unary (arity 1) → max = 7
- **Stage 3**: Add ternary (arity 3) → max = 16
- Progression demonstrating how higher arities enable larger nice sets
- Final confirmation: **max size = 16** (matches theoretical bound)

**Key Insights:**
- **Binary only**: 3 functions max
- **Binary + Unary**: 7 functions max (133% improvement!)
- **Binary + Unary + Ternary**: 16 functions max (129% improvement!)
- Ternary connectives are **essential** for reaching theoretical maximum
- Final result matches theoretical upper bound (**tight bound**)

**Example Output Snippet:**
```
============================================================
Adding arity 2 connectives...
============================================================
Arity 2 result: max size = 3

============================================================
Adding arity 1 connectives...
============================================================
Arity 1 result: max size = 7
NEW BEST: 7 (was 3)

============================================================
Adding arity 3 connectives...
============================================================
Arity 3 result: max size = 16
NEW BEST: 16 (was 7)

FINAL RESULT: Maximum nice set size = 16
```

**Interpretation:**
- Each stage adds more connectives to the pool
- Search finds maximum nice set from expanded pool
- Unary functions (IDENTITY, NEGATION, constants) double the max size
- Ternary functions (256 total) enable jump to theoretical maximum
- Typical size-16 set: **1 binary + 15 ternary** functions

**Why the progression?**
1. **Binary only (max=3)**: Limited expressiveness, all functions are related
2. **Add unary (max=7)**: Negation and identity enable new combinations
3. **Add ternary (max=16)**: Higher arity provides enough independence

---

### [validation.txt](validation.txt)

*Quick validation confirming a size-16 nice set is complete and independent*

**Command:**
```bash
python3 -m src.main --validate
```

**What it shows:**
- Verification of a known size-16 nice set
- Confirmation it's complete (escapes all 5 Post classes)
- Confirmation it's independent (no function definable from others)
- Arity distribution (1 binary, 15 ternary)
- Quick validation check (< 1 second)

**Key Insights:**
- Validates that size-16 sets actually exist
- Confirms completeness via Post's lattice (T0, T1, M, D, A)
- Confirms independence via composition depth 3 checking
- **Very fast** - useful for regression testing
- Proves theoretical upper bound is **achievable**

**Example Output:**
```
VALIDATING MAXIMUM NICE SET SIZE = 16

✓ VALIDATION SUCCESSFUL
  Set is valid (complete and independent)

  Escapes all Post classes: True
  Arity distribution: {2: 1, 3: 15}

CONFIRMED: Maximum nice set size = 16

This matches the theoretical upper bound of 16 for
complete and independent sets in classical logic.
```

**Interpretation:**
- **Escapes all Post classes**: Set is complete (can define all connectives)
- **Arity distribution {2: 1, 3: 15}**: 1 binary + 15 ternary functions
- **Validation successful**: Confirms both completeness AND independence
- Theoretical upper bound is **tight** (maximum exists and is achievable)

---

## Understanding the Output

### Function Naming Convention

Functions are named using the pattern `fA_X`:
- **A** = arity (number of inputs)
- **X** = truth table encoding (integer representation)

**Examples:**
- `f2_0` = binary function, encoding 0 (constant FALSE: 0000)
- `f2_6` = binary function, encoding 6 (XOR: 0110)
- `f2_8` = binary function, encoding 8 (AND: 1000)
- `f2_14` = binary function, encoding 14 (OR: 1110)
- `f1_1` = unary function, encoding 1 (NEGATION: 01)
- `f1_2` = unary function, encoding 2 (IDENTITY: 10)
- `f3_23` = ternary function, encoding 23 (some ternary truth table)

### Truth Table Encodings

For binary functions (arity 2), the encoding is a 4-bit number:

| Inputs | Row | Bit Position |
|--------|-----|--------------|
| (0,0)  | 0   | bit₀         |
| (0,1)  | 1   | bit₁         |
| (1,0)  | 2   | bit₂         |
| (1,1)  | 3   | bit₃         |

**Example: AND (f2_8)**
```
x | y | AND | Bit
0 | 0 |  0  | bit₀ = 0
0 | 1 |  0  | bit₁ = 0
1 | 0 |  0  | bit₂ = 0
1 | 1 |  1  | bit₃ = 1

Encoding: 1000₂ = 8
```

**Example: XOR (f2_6)**
```
x | y | XOR | Bit
0 | 0 |  0  | bit₀ = 0
0 | 1 |  1  | bit₁ = 1
1 | 0 |  1  | bit₂ = 1
1 | 1 |  0  | bit₃ = 0

Encoding: 0110₂ = 6
```

For ternary functions (arity 3), the encoding is an 8-bit number (256 possibilities).

### Search Progress

Search output shows progress through combination sizes:

```
Searching for nice sets of size 3...
Total combinations to check: 560
  Found nice set: ['f2_0', 'f2_7', 'f2_9']
  Found nice set: ['f2_0', 'f2_7', 'f2_10']
  [...]
Found 76 nice sets of size 3
Size 3: Found 76 nice sets (0.24s)
```

**Interpretation:**
- **C(16, 3) = 560**: Number of ways to choose 3 from 16 binary connectives
- **Found 76 nice sets**: 76 of those 560 combinations are nice
- **(0.24s)**: Time to check all 560 combinations
- Algorithm checks completeness first (fast), then independence (slower)

### Timing Information

**Binary-only search:**
- Size 1: ~0.00s (trivial)
- Size 2: ~0.02s (120 combinations)
- Size 3: ~0.24s (560 combinations)
- Size 4: ~1.41s (1820 combinations, all fail)
- Size 5: ~3.96s (4368 combinations, all fail)

**Why increasing time?**
- More combinations to check: C(16, k) grows with k
- Independence checking gets more expensive (more functions to verify)
- Failed searches still check all combinations

**Incremental search with ternary:**
- Binary stage: ~6 seconds
- Unary stage: ~2-4 minutes (more combinations)
- Ternary stage: Varies (many more connectives in pool)

---

## Reproducing Examples

All examples can be reproduced by running the commands listed above:

```bash
# Binary-only search
python3 -m src.main --binary-only > examples/my_binary_search.txt

# Validation (fast)
python3 -m src.main --validate > examples/my_validation.txt

# Full incremental search (slow - may take several minutes)
python3 -m src.main --max-arity 3 > examples/my_full_search.txt
```

**Note:** Exact timing may vary based on your hardware, but relative timings and maximum sizes should be consistent.

---

## Additional Examples

For more examples including benchmarking and depth analysis, see:
- [scripts/README.md](../scripts/README.md) - Benchmarking and validation scripts
- [USAGE.md](../USAGE.md) - Command-line usage guide
- [RESULTS.md](../RESULTS.md) - Research results and analysis

---

## Navigation

- [← Project README](../README.md)
- [Usage Guide](../USAGE.md)
- [Results](../RESULTS.md)
- [Scripts](../scripts/README.md)
