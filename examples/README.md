# Examples Directory

Real execution examples showing what the Nice Connectives Solver produces.

## Overview

This directory contains actual output from running the solver with different configurations:
- **[binary_only_search.txt](binary_only_search.txt)** - Complete binary-only search output (max=3)
- **[incremental_search_summary.txt](incremental_search_summary.txt)** - Incremental progression 3→7→16
- **[validation.txt](validation.txt)** - Quick validation of size-16 nice set
- **[depth_results.csv](depth_results.csv)** - Benchmark data across depths 1-5

These examples help users understand:
- What output to expect from different commands
- How long searches take
- What the progression from binary to ternary looks like
- How performance scales with composition depth
- How to interpret results

All examples were generated by running the commands documented in [USAGE.md](../USAGE.md).

---

## Example Files

### [binary_only_search.txt](binary_only_search.txt)

*Complete output from binary-only search demonstrating max size = 3*

**Command:**
```bash
python3 -m src.main --binary-only
```

**What it shows:**
- Search through all 16 binary connectives
- Progressive search from size 1 → 2 → 3 → 4 → 5
- Confirmation that max size = 3 (classical result)
- Example of 76 different size-3 nice sets found
- Timing information for each search size

**Key Insights:**
- Binary-only max is **3** (confirms classical result)
- Found 76 different maximal nice sets
- Size 4 and higher: **no nice sets exist** with binary only
- Total search time: ~5-6 seconds
- Most time spent checking sizes 4 and 5 (which have no solutions)

**Example Output Snippet:**
```
Size 3: Found 76 nice sets (0.24s)
Size 4: No nice sets found (1.41s)
Size 5: No nice sets found (3.96s)

RESULT: Maximum nice set size = 3

Example nice sets:
  Set 1: ['f2_0', 'f2_7', 'f2_9']
  Set 2: ['f2_0', 'f2_7', 'f2_10']
  Set 3: ['f2_0', 'f2_7', 'f2_12']
```

**Interpretation:**
- `f2_X` notation: binary function (arity 2) with truth table encoding X
- `f2_0` = constant FALSE (0000 in binary)
- `f2_7` = NOR (0001 in binary  - only true when both inputs false)
- `f2_9` = XNOR/IFF (1001 in binary - true when inputs match)

---

### [incremental_search_summary.txt](incremental_search_summary.txt)

*Summary of incremental search showing progression: binary (3) → unary (7) → ternary (16)*

**Command:**
```bash
python3 -m src.main --max-arity 3
```

**What it shows:**
- **Stage 1**: Add binary (arity 2) → max = 3
- **Stage 2**: Add unary (arity 1) → max = 7
- **Stage 3**: Add ternary (arity 3) → max = 16
- Progression demonstrating how higher arities enable larger nice sets
- Final confirmation: **max size = 16** (matches theoretical bound)

**Key Insights:**
- **Binary only**: 3 functions max
- **Binary + Unary**: 7 functions max (133% improvement!)
- **Binary + Unary + Ternary**: 16 functions max (129% improvement!)
- Ternary connectives are **essential** for reaching theoretical maximum
- Final result matches theoretical upper bound (**tight bound**)

**Example Output Snippet:**
```
============================================================
Adding arity 2 connectives...
============================================================
Arity 2 result: max size = 3

============================================================
Adding arity 1 connectives...
============================================================
Arity 1 result: max size = 7
NEW BEST: 7 (was 3)

============================================================
Adding arity 3 connectives...
============================================================
Arity 3 result: max size = 16
NEW BEST: 16 (was 7)

FINAL RESULT: Maximum nice set size = 16
```

**Interpretation:**
- Each stage adds more connectives to the pool
- Search finds maximum nice set from expanded pool
- Unary functions (IDENTITY, NEGATION, constants) double the max size
- Ternary functions (256 total) enable jump to theoretical maximum
- Typical size-16 set: **1 binary + 15 ternary** functions

**Why the progression?**
1. **Binary only (max=3)**: Limited expressiveness, all functions are related
2. **Add unary (max=7)**: Negation and identity enable new combinations
3. **Add ternary (max=16)**: Higher arity provides enough independence

---

### [validation.txt](validation.txt)

*Quick validation confirming a size-16 nice set is complete and independent*

**Command:**
```bash
python3 -m src.main --validate
```

**What it shows:**
- Verification of a known size-16 nice set
- Confirmation it's complete (escapes all 5 Post classes)
- Confirmation it's independent (no function definable from others)
- Arity distribution (1 binary, 15 ternary)
- Quick validation check (< 1 second)

**Key Insights:**
- Validates that size-16 sets actually exist
- Confirms completeness via Post's lattice (T0, T1, M, D, A)
- Confirms independence via composition depth 3 checking
- **Very fast** - useful for regression testing
- Proves theoretical upper bound is **achievable**

**Example Output:**
```
VALIDATING MAXIMUM NICE SET SIZE = 16

✓ VALIDATION SUCCESSFUL
  Set is valid (complete and independent)

  Escapes all Post classes: True
  Arity distribution: {2: 1, 3: 15}

CONFIRMED: Maximum nice set size = 16

This matches the theoretical upper bound of 16 for
complete and independent sets in classical logic.
```

**Interpretation:**
- **Escapes all Post classes**: Set is complete (can define all connectives)
- **Arity distribution {2: 1, 3: 15}**: 1 binary + 15 ternary functions
- **Validation successful**: Confirms both completeness AND independence
- Theoretical upper bound is **tight** (maximum exists and is achievable)

---

### [depth_results.csv](depth_results.csv)

*Benchmark data showing performance across composition depths 1-5*

**Command:**
```bash
./scripts/benchmark_depth.py --depths 1,2,3,4,5 --runs 3 --output depth_results.csv
```

**What it shows:**
- Performance measurements for depths 1 through 5
- Average, minimum, and maximum search times
- Standard deviation across runs
- Maximum nice set size found at each depth
- Number of nice sets found at each depth

**Sample Data:**
```csv
Depth,Runs,Avg Time (s),Min Time (s),Max Time (s),Std Dev (s),Max Size,Avg Num Sets
1,3,0.0149,0.0121,0.0198,0.0035,5,6.0
2,3,0.0121,0.0118,0.0123,0.0002,3,7.0
3,3,0.0202,0.0179,0.0220,0.0017,3,1.0
4,3,0.0246,0.0227,0.0279,0.0024,3,1.0
5,3,0.0335,0.0316,0.0354,0.0016,3,1.0
```

**Key Insights:**
- **Depth 1**: Fast but incorrect (max=5 is wrong, should be 3)
  - Shallow depth misses dependencies, reports false positives
- **Depth 2**: Faster than depth 1, correct result (max=3)
  - Minimal depth needed for binary-only correctness
- **Depth 3**: Standard depth, correct result (max=3)
  - Recommended default balancing correctness and performance
- **Depth 4-5**: Slower, same result (max=3)
  - Diminishing returns, no new information
- **Performance growth**: ~50% increase from depth 3 to 5
  - Exponential growth in search time with depth

**Interpretation:**
- **Depth matters for correctness**: Depth 1 gives wrong answer
- **Depth 2-5 agree**: All find max=3 (consistency check)
- **Depth 3 is optimal**: Good balance of speed and correctness
- **Higher depths costly**: 66% slower at depth 5 vs depth 3
- **Use for analysis**: Study depth/performance trade-offs

**Use Cases:**
- Validate that depth 3 is sufficient for binary-only
- Study performance scaling with composition depth
- Justify choice of depth parameter in research
- Compare hardware performance across systems
- Benchmark optimizations to search algorithms

**CSV Format:**
Standard comma-separated values, easily imported into:
- Spreadsheets (Excel, Google Sheets, LibreOffice Calc)
- Data analysis tools (Python pandas, R)
- Plotting libraries (matplotlib, ggplot2)
- Statistical software (SPSS, SAS)

---

## Understanding the Output

### Function Naming Convention

Functions are named using the pattern `fA_X`:
- **A** = arity (number of inputs)
- **X** = truth table encoding (integer representation)

**Examples:**
- `f2_0` = binary function, encoding 0 (constant FALSE: 0000)
- `f2_6` = binary function, encoding 6 (XOR: 0110)
- `f2_8` = binary function, encoding 8 (AND: 1000)
- `f2_14` = binary function, encoding 14 (OR: 1110)
- `f1_1` = unary function, encoding 1 (NEGATION: 01)
- `f1_2` = unary function, encoding 2 (IDENTITY: 10)
- `f3_23` = ternary function, encoding 23 (some ternary truth table)

### Truth Table Encodings

For binary functions (arity 2), the encoding is a 4-bit number:

| Inputs | Row | Bit Position |
|--------|-----|--------------|
| (0,0)  | 0   | bit₀         |
| (0,1)  | 1   | bit₁         |
| (1,0)  | 2   | bit₂         |
| (1,1)  | 3   | bit₃         |

**Example: AND (f2_8)**
```
x | y | AND | Bit
0 | 0 |  0  | bit₀ = 0
0 | 1 |  0  | bit₁ = 0
1 | 0 |  0  | bit₂ = 0
1 | 1 |  1  | bit₃ = 1

Encoding: 1000₂ = 8
```

**Example: XOR (f2_6)**
```
x | y | XOR | Bit
0 | 0 |  0  | bit₀ = 0
0 | 1 |  1  | bit₁ = 1
1 | 0 |  1  | bit₂ = 1
1 | 1 |  0  | bit₃ = 0

Encoding: 0110₂ = 6
```

For ternary functions (arity 3), the encoding is an 8-bit number (256 possibilities).

### Search Progress

Search output shows progress through combination sizes:

```
Searching for nice sets of size 3...
Total combinations to check: 560
  Found nice set: ['f2_0', 'f2_7', 'f2_9']
  Found nice set: ['f2_0', 'f2_7', 'f2_10']
  [...]
Found 76 nice sets of size 3
Size 3: Found 76 nice sets (0.24s)
```

**Interpretation:**
- **C(16, 3) = 560**: Number of ways to choose 3 from 16 binary connectives
- **Found 76 nice sets**: 76 of those 560 combinations are nice
- **(0.24s)**: Time to check all 560 combinations
- Algorithm checks completeness first (fast), then independence (slower)

### Timing Information

**Binary-only search:**
- Size 1: ~0.00s (trivial)
- Size 2: ~0.02s (120 combinations)
- Size 3: ~0.24s (560 combinations)
- Size 4: ~1.41s (1820 combinations, all fail)
- Size 5: ~3.96s (4368 combinations, all fail)

**Why increasing time?**
- More combinations to check: C(16, k) grows with k
- Independence checking gets more expensive (more functions to verify)
- Failed searches still check all combinations

**Incremental search with ternary:**
- Binary stage: ~6 seconds
- Unary stage: ~2-4 minutes (more combinations)
- Ternary stage: Varies (many more connectives in pool)

---

## Reproducing Examples

All examples can be reproduced by running the commands listed above:

```bash
# Binary-only search
python3 -m src.main --binary-only > examples/my_binary_search.txt

# Validation (fast)
python3 -m src.main --validate > examples/my_validation.txt

# Full incremental search (slow - may take several minutes)
python3 -m src.main --max-arity 3 > examples/my_full_search.txt

# Depth benchmark
./scripts/benchmark_depth.py --depths 1,2,3,4,5 --runs 3 --output examples/my_depth_results.csv
```

**Note:** Exact timing may vary based on your hardware, but relative timings and maximum sizes should be consistent.

---

## Additional Examples

For more examples and tools:
- [scripts/README.md](../scripts/README.md) - Benchmarking and validation scripts (benchmark.py, quick_benchmark.py)
- [USAGE.md](../USAGE.md) - Command-line usage guide with all options
- [RESULTS.md](../RESULTS.md) - Research results and comprehensive analysis
- [depth_results.csv](depth_results.csv) - Benchmark data showing depth/performance trade-offs

---

## Navigation

- [← Project README](../README.md)
- [Usage Guide](../USAGE.md)
- [Results](../RESULTS.md)
- [Scripts](../scripts/README.md)
